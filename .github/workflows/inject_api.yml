name: Inject API (Safe)

on:
  workflow_dispatch:
    inputs:
      write_env_file:
        description: "Write a temp env file for subsequent steps (NOT committed)."
        required: false
        default: "true"
      env_file_path:
        description: "Path to write env file. Default uses RUNNER_TEMP."
        required: false
        default: ""
      upload_artifact:
        description: "Upload env file as artifact for downstream jobs."
        required: false
        default: "true"
      artifact_name:
        description: "Artifact name if upload_artifact=true"
        required: false
        default: "api-env"
      python_version:
        description: "Python version to use if installing/running scripts."
        required: false
        default: "3.12"

  workflow_call:
    inputs:
      write_env_file:
        type: string
        required: false
        default: "true"
      env_file_path:
        type: string
        required: false
        default: ""
      upload_artifact:
        type: string
        required: false
        default: "true"
      artifact_name:
        type: string
        required: false
        default: "api-env"
      python_version:
        type: string
        required: false
        default: "3.12"
    secrets:
      API_TOKEN:
        required: true
      API_BASE_URL:
        required: false

  push:
    branches:
      - main
    paths:
      - ".github/workflows/inject_api.yml"
      - "requirements.txt"
      - "server.py"
      - "scripts/**"
      - "src/**"

permissions:
  contents: read

concurrency:
  group: inject-api-${{ github.ref }}
  cancel-in-progress: true

jobs:
  inject:
    name: Inject API secrets into runner env (safe)
    runs-on: ubuntu-latest
    timeout-minutes: 10

    # Normalize inputs for all trigger types:
    # - workflow_dispatch: github.event.inputs.*
    # - workflow_call: inputs.*
    # - push: neither exists -> fall back to defaults
    env:
      WRITE_ENV_FILE: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.write_env_file) || inputs.write_env_file || 'true' }}
      UPLOAD_ARTIFACT: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.upload_artifact) || inputs.upload_artifact || 'true' }}
      ARTIFACT_NAME: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.artifact_name) || inputs.artifact_name || 'api-env' }}
      PYTHON_VERSION: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.python_version) || inputs.python_version || '3.12' }}

      # Default env file path uses RUNNER_TEMP to avoid accidentally committing secrets.
      # If user provides env_file_path, we will use it.
      ENV_FILE_PATH_INPUT: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.env_file_path) || inputs.env_file_path || '' }}

      PIP_DISABLE_PIP_VERSION_CHECK: "1"
      PYTHONDONTWRITEBYTECODE: "1"
      PYTHONUNBUFFERED: "1"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets exist
        shell: bash
        env:
          API_TOKEN: ${{ secrets.API_TOKEN }}
        run: |
          set -euo pipefail
          if [[ -z "${API_TOKEN:-}" ]]; then
            echo "ERROR: Missing required secret: API_TOKEN"
            echo "Add it in: Settings -> Secrets and variables -> Actions -> New repository secret"
            exit 1
          fi

      - name: Mask secrets (prevent accidental log exposure)
        shell: bash
        env:
          API_TOKEN: ${{ secrets.API_TOKEN }}
          API_BASE_URL: ${{ secrets.API_BASE_URL }}
        run: |
          set -euo pipefail
          echo "::add-mask::${API_TOKEN}"
          if [[ -n "${API_BASE_URL:-}" ]]; then
            echo "::add-mask::${API_BASE_URL}"
          fi

      - name: Export secrets to job environment (safe)
        shell: bash
        env:
          API_TOKEN: ${{ secrets.API_TOKEN }}
          API_BASE_URL: ${{ secrets.API_BASE_URL }}
        run: |
          set -euo pipefail
          {
            echo "API_TOKEN=${API_TOKEN}"
            if [[ -n "${API_BASE_URL:-}" ]]; then
              echo "API_BASE_URL=${API_BASE_URL}"
            fi
          } >> "${GITHUB_ENV}"

      - name: Resolve env file path
        id: resolve_path
        shell: bash
        run: |
          set -euo pipefail
          if [[ -n "${ENV_FILE_PATH_INPUT:-}" ]]; then
            ENV_FILE_PATH="${ENV_FILE_PATH_INPUT}"
          else
            ENV_FILE_PATH="${RUNNER_TEMP}/api.env"
          fi
          echo "env_file_path=${ENV_FILE_PATH}" >> "${GITHUB_OUTPUT}"

      - name: Write env file for subsequent steps (NOT committed)
        if: ${{ env.WRITE_ENV_FILE != 'false' }}
        shell: bash
        env:
          API_TOKEN: ${{ secrets.API_TOKEN }}
          API_BASE_URL: ${{ secrets.API_BASE_URL }}
          ENV_FILE_PATH: ${{ steps.resolve_path.outputs.env_file_path }}
        run: |
          set -euo pipefail
          umask 077

          mkdir -p "$(dirname "${ENV_FILE_PATH}")"
          : > "${ENV_FILE_PATH}"

          # Do NOT echo secret values to logs.
          printf "API_TOKEN=%s\n" "${API_TOKEN}" >> "${ENV_FILE_PATH}"
          if [[ -n "${API_BASE_URL:-}" ]]; then
            printf "API_BASE_URL=%s\n" "${API_BASE_URL}" >> "${ENV_FILE_PATH}"
          fi

          chmod 600 "${ENV_FILE_PATH}"

      - name: Upload env file as artifact (optional)
        if: ${{ env.UPLOAD_ARTIFACT != 'false' && env.WRITE_ENV_FILE != 'false' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ steps.resolve_path.outputs.env_file_path }}
          if-no-files-found: error
          retention-days: 1

      - name: Setup Python (optional)
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: "pip"

      - name: Install dependencies (optional)
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          if [[ -f "requirements.txt" ]]; then
            pip install -r requirements.txt
          else
            echo "requirements.txt not found; skipping."
          fi

      - name: Example - run script using injected env (optional)
        shell: bash
        env:
          API_TOKEN: ${{ env.API_TOKEN }}
          API_BASE_URL: ${{ env.API_BASE_URL }}
        run: |
          set -euo pipefail
          # IMPORTANT: never print $API_TOKEN.
          if [[ -f "scripts/inject_api.py" ]]; then
            python scripts/inject_api.py
          else
            echo "No scripts/inject_api.py found; injection complete."
          fi
